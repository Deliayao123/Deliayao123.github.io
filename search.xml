<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《区块链核心技术与应用》读书笔记]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这段时间忙于复习专业课，所以没有好好看区块链的书籍，今天抽空看一了本最近刚出版的书，是邹均、于斌等写的《区块链核心技术与应用》 我从知道区块链到现在已经把我们学校图书馆所有关于区块链的书籍都翻过了，有的从头到尾仔细看过，有的看了几眼放下来，也有的认真看了几章放弃了。归根结底还是因为现在关于区块链的书籍大差不差，而且很多都是站在金融视角进行阐述，对于理工科的我来说更想看到区块链技术方面的书籍，这一本是为数不多的涉及技术层面的书籍中让我看得最头疼的一本，这也恰恰说明这本书值得我仔细阅读，今天下午我花了2个小时只看了几页，是不是很神奇！看的我脑壳疼！ 最近一直迷恋东野圭吾的小说，看起来几乎不费脑。突然看这么技术性的书籍真的让我有点措手不及！ 这本书最大的特点就是用心！不仅讲了区块链是什么，由哪些技术组成，还讲了为什么是这样，自上向下讲原理，讲技术！很喜欢！我会在元旦前把这本书看完，再来分享读书笔记！———————————————————————————————2018.12.19]]></content>
      <tags>
        <tag>日报</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统结构———量化研究方法]]></title>
    <url>%2F2018%2F12%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在复习计算机系统结构这门课程，用的是如下的复习书 本来我觉得计算理论应该是我复习最头疼的书了，没想到这本书对于完全不懂计算机硬件的我来说更难理解！应该用第五版的，但是没办法图书馆只能借到这一版，所以就将就看好了，但是第四版和第五版还是有不少差别的，建议同学们还是用第五版！更神奇的是这本书的附录部分竟然占了全书篇幅的三分之一还要多，而且附录部分还有很多考点！附录A,B,C都很重要，是学习正文部分的基础，我明天再回顾一下附录好了！学起来实在是太吃力了！ 第一章本书第一章讲了计算机设计基本原理，大部分是普及类知识，其中计算机设计的五个量化原则是经常考的题目，而且还要懂得怎么用Amdahl定律做题。 第二章第二章是重点，全部都很重要！什么是ILP循环展开预测技术：静态和动态转移预测动态调度两个算法：CDC记分牌和Tomasulo算法推测技术多发射 第三章很多学校都没有讲第三章内容，感兴趣可以看看。 第四章这一章一定要搞明白cache一致性方法、同步、存储连贯性模型！并行处理遇到的挑战对称式共享存储器系统结构和监听协议分布式共享存储器结构和目录协议同步怎么实现存储器连贯性模型有哪些，各自的性能怎么样 第五章和第六章我还是纠结要不要复习，我看往年的题似乎没有涉及到这两章的知识]]></content>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算理论解析》读书笔记]]></title>
    <url>%2F2018%2F11%2F20%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天看了一本专业课的讲解书，是张寅生所写的《计算理论解析》等我把计算理论基础完全吃透后，再来分享一波！最近我在学习的过程中感觉自己好渺小，各个领域都有神一般存在的人物，所以最近经常反思自己和大牛们的差别到底在哪里。虽然我经常看到很多人在网络上宣称区块链是泡沫，区块链无法实现落地，但是我依然看到很多为区块链找到合适落地场景的极客们，感觉他们不会那么在意外界的声音，而更多专注于自己内心的声音，所以我最近也每天泡图书馆，在寻找自己内心的声音，让自己沉淀下来。 我发现我即使看一个月，计算理论解析这本书我也吃不透！实在是太难了！我先把我会的一丢丢写下来吧！我复习是下面这本书 提纲一共分为七章1 集合、关系和语言：这一张是离散数学的一些基础知识，本人觉得理解起来不吃力；2 有穷自动机：这一章和编译原理非常类似，说的是有穷自动机和正则语言的关系；3 上下文无关文法：这里说的是下推自动机和上下文无关文法的关系：第二、三章其实不难理解，但是就是不会做题，我不懂为什么！4 Turing机：我的妈！这一章理解起来有点费力了，更别说做题了！5 不可判定型：这一章是什么鬼？？？完全看不懂啊！6 计算复杂性：说的是P和NP的问题，主要是讲解如何用规约法证明问题是NP之类的；7 NP完全性：是第七章的延申，证明题也主要是用规约法，但是规约法怎么用啊！我还没有搞清楚！ 2018.11.30我又来交作业了，这几天一直在忙着我家喵喵的事情，教育小猫不咬主人真的好难啊！最近感觉做了几张计算理论基础的卷子突然开窍了，类型都大差不差，知道思路但就是不会细节，已经算是有长远的进步了吧！这几天理论学习太多想动手做做项目，之前看有大神作过区块链微信小程序，感觉挺有意思，我打算尝试复现一下！ 2018.12.21我实在是一个没有耐心的人，喵喵被我送走了！最近复习计算理论感觉越来越得心应手了，从网上找到一个总结的很好的贴子，内容如下！ 其最关注的问题是什么是可计算性，什么问题可计算，问题之间的映射/归约，计算代价及难易。在分析问题和检验模型计算能力之前需要掌握的工具是形式语言、图灵机等。本文主要对计算理论中的重点进行了总结，总结了一些定理和理解上容易有障碍的知识点，但是里面还有一些点没有提到，比如NFA、DFA的相互转化，CFL和PDA的相互转化，需要书中的题目和证明辅助。Textbook Summary 与自然数集合N等势的集合是可数无穷的，称有穷的or可数无穷的集合是可数的。非可数的集合称作不可数的。 DFA ( K, Σ, s, F, δ ) ；NFA（K, Σ，s，F，Δ） 每台NFA都有一台等价的DFA（method: find closure） 有穷自动机接受的语言类 = 正则语言类（正则表达式描述的语言类） 正则语言在各种运算下封闭 语言是正则的，iff 其等价语言中有有穷个等价类。 DFA状态最小化-&gt;寻找等价类（初始等价类F &amp; K-F） CFL（V，Σ，R，S） 存在非正则的CFL 能够生成&gt;=两棵语法分析树的字符串的文法叫做歧义的。 PDA M=（K，Σ，Γ，Δ，s，F），Γ为栈符号 PDA接受的语言正好是CFL 正则语言（xynz）和CFL（uvnxynz）的泵定理 L={anbn}∈CFL，L={anbncn}∉CFL但是是递归的，L={an,n为素数}不是CFL Chomsky范式（CNF）：若R⊆(V-Σ)×V2，则称G=（V，Σ，R，S）为Chomsky范式 有穷自动机总是停机。 CFG到CNF的转化：1) 消除长rules2) 消除空rules（A-&gt;e）3) 消除短rules（A-&gt;a or A-&gt;B） 对任意CFL G，都可以在多项式时间构造Chomsky范式G’,使得L(G’)=L(G)-(Σ∪{e}) 没有chomsky范式能够表示length&lt;2的字符串，所以包含&lt;2的字符串的语言不能转化到chomsky范式。 确定型CFL（确定型PDA接受的语言类）在补下封闭。 TM (K，Σ，δ，s，H)，注意字母表Σ不包含←和→ 若存在TM判定L，则称L是递归的。 如果对于所有w属于Σ*，M(w) = f(w)，我们说M计算函数f，若存在TM计算f，则f称为递归的。 半判定语言的TM都不是算法 多带、多带头、双向无穷带or多维带的TM，其判定or半判定的任何语言及任何函数，都分别可用标准TM判定、半判定or计算。 非确定型TM：一个格局可在一步里产生多个其他格局，NDTM is no more powerful than original TM 若非确定型TM M半判定或者判定语言L，或者计算函数f，则存在标准型TM M’半判定or判定L，or计算函数f。 文法是CFG的推广，任何CFG都是文法。G=（V，Σ，R，S） 语言被文法生成iff它是r.e.的。 所有数值函数都是原始递归的 原始递归函数集是递归可枚举的。 特殊语言/问题：H = {“M””w”: M在w上停机 }﹁H = { “M””w”：M是一台在”w”上不停机的TM }H1 = {“M”：M在“M”上停机 }﹁H1 = { w：要么w不是一台TM的编码，要么w是M的编码，M是一台在”M”上不停机的TM }H：r.e. ; H1：r.e.； ﹁H, ﹁H1：非r.e. ； 2-SAT∈P； SAT∈NP 没有算法的问题称作不可判定的or不可解的，如TM的停机问题 证明不可判定：从通用图灵机U通过递归函数归约到L，如果L是递归的则U是递归的。i.e.若L1非递归，并存在L1到L2的归约，则L2也非递归。递归函数是Turing Computable的。 语言是图灵可枚举的，iff存在枚举它的图灵机。（M通过空格代开始，周期性的经过特殊状态q来枚举L，任意顺序且可重复） 不可判定语言与递归语言互为补集，与r.e.语言有交集。 语言是r.e.，iff它是图灵可枚举的；语言是递归的，iff它是以字典序Turing可枚举的。 P在并交连接和补运算下封闭，NP在并、连接运算下封闭。若NP在补下封闭，则NP=P。 H = {“M””w”: M在最多2|w|步后停机 } ∉ P 所有正则语言和所有CFL都属于P NP：A. 机器角度去定义：被多项式界限非确定型图灵机判定的所有语言的类。B. 基于verifier的定义：NP问题上建立的非确定机包含两步：1) 非确定地猜一个解2) 用一个确定的算法判定该解是否为可行解判定一个给定猜测值是否满足该问题这两个定义是不矛盾的，因为如果一台非确定TM在多项式时间内可以判定一个非确定选择的输入是否满足，就是基于verifier的定义。 （可满足性）的算法称作verifier，一个问题称作NP问题当且仅当存在一个多项式时间的verifier。P和NP的区别：A problem is in P if we can decide them in polynomial time. It is in NP if we can decide them in polynomial time, if we are given the right certificate. 若存在计算函数f的多项式界限的图灵机M，则f称为多项式时间可计算的。 若τ1是L1-&gt;L2的多项式归约，τ2是L2-&gt;L3的多项式归约，则τ1·τ2是L1-&gt;L3的多项式归约。 证明NP完全：法一、按定义：L⊆Σ*，若（a） L∈NP，且（b） 对每个语言L’∈NP，存在从L’到L的多项式归约则L称为NP完全的。法二、归约，对于语言L，（a） 若L∈NP（b） 一个NP完全问题可以在多项式时间规约到L，i.e. SAT ≤p L则L称为NP完全的。 L是NP完全语言，则P=NP，iff L∈P SAT是NP-complete，3-SAT，最大可满足性也是NP完全的 覆盖问题，Hamilton圈（有向无向），旅行商问题，背包问题都是NP-complete。 abc* - {anbncn, n ≥ 0} is context-free but not regular L=L1L2，L是CFL，则L1一定是CFL （×） Regular-CFL不一定是CFL，如abc*-anbn包含anbncn 2-way PDA(i.e. PDA whose input heads can move both left and right) are more powerful than 1-way PDA Given a PDA M1 and an FA M2, the problem L(M1) ⊆L(M2) is decidable DFA/NFA识别的是exactly正则语言。 R.e. 只在补和差下不封闭，CFL在交下也不封闭。 非正则语言的可能是正则语言。比如A:{ w=wR },及所有回文，A=Σ*，为正则语言 典型非正则：w=wR 正则语言的子集可能非正则，如anbncn,是abc的子集；又如Σ是正则语言，H ⊆Σ*。 归约：X到Y的归约可以理解为X到Y问题的映射, reduction可以解释为at least as difficult as… 比如X可以被Y的算法解决，则X is no more difficult than Y, X可以归约到Y，记X≤Y。e.g. x2可以归约到任意两数的乘积。∴ 若有A≤rB，A是不可判定问题-&gt;B不可判定 A不递归-&gt;B不递归B可判定-&gt;A可判定 B是递归的-&gt;A是递归的 若X多项式时间归约到Y，Y多项式时间可解，则X多项式时间可解；若X多项式时间归约到Y，X多项式时间不可解，则Y多项式时间不可解 X多项式时间归约到Y，Y多项式时间归约到Z，则X多项式时间归约到Z PRIME（COMPOSITE）多项式时间归约到Factor，但是Factor多项式时间不能归约到PRIME（COMPOSITE）。 若A≤PB，B∈NP，则A∈NP。证明：A≤PB⇒存在确定图灵机X，可将A归约到B。B∈NP⇒ 存在一个非确定图灵机N可判定B。我们希望构造一个新的TM（XN），是的XN非确定多项式时间求解A，则A∈NP。Running time of X*N≤1+p(n)B&gt;+q(p(n))(B多项式时间非确定判定)是多项式时间所以A∈NP 若A≤PB，B∈P，则A∈P。 若X是NPC的，则X在多项式时间内可解iff P=NP. SAT多项式时间归约到3-SAT(3-SAT是NPC的) 证明语言L是R./R.e./Non R.e.a) Intuitively想想有没有半判定（判定）的TM，有则R.e.(R)。若非R,执行下一步。b) 用能否由R.e.（Non R.e.）语言归约到该语言，能则R.e.而非R（Non R.e）.严格用归约函数定义f：A≤pB，r1∈A当且仅当f(r1)∈Be.g.1 &lt;M,w&gt;∈H, iff M∈L 证明R.e.e.g.2 &lt;M,w&gt;∈非H，iff M∈L 证明Non R.e.注意方向：是从A的实例经过递归函数推向B的实例。详细介绍：http://www.cs.rice.edu/~nakhleh/COMP481/final_review_sp06_sol.pdf 递归与μ递归等价 PDA中，若每一个格局至多有一个格局接在它后面，则为确定型的。确定型CFL在补下封闭。 M半判定L：w∈L，iff M在w上停机，注意半判定图灵机中不存在“拒绝”状态。只要不接受w，就不停机。 Chomsky hierarchy 俩证明：7.6 证明P在并、交、Kleene*连接和补运算下封闭。(1) 并：对任意 L1, L2∈P，设有na时间图灵机M1和nb时间图灵机M2 判定它们，且c=max{a,b}。对L1∪L2 构造判定器M:M=“对于输入字符串w :1) 在w上运行M1，在w上运行M2。2) 若有一个接受则接受，否则拒绝。”时间复杂度：设M1为O(na),M2为O(nb)。令c=max{a,b}。第一步用时O(na+nb) ，因此总时间为O(na+ nb)=O(nc),所以L1∪L2属于P类，即 P在并的运算下封闭。(2) 连接：对任意 L1, L2 属于P 类，设有na时间图灵机M1和nb时间图灵机M2 判定它们，且c=max{a,b}。对L1L2 构造判定器M:M=“对于输入字符串w=w1,w2,…,wn，1) 对k=0,1,2,…,n重复下列步骤。2) 在w1w2…wk上运行M1，在wk+1wk+2…wn上运行M2。3) 若都接受，则接受。否则继续。4) 若对所有分法都不接受则拒绝。“时间复杂度：(n+1)×(O(na)+O(nb))=O(na+1)+O(nb+1)=O(nc+1)，所以L1L2属于P类，即 P在连接的运算下封闭。(3)补：对任意 L1属于P 类，设有时间O(na)判定器M1判定它，对1L构造判定器M:M=“对于输入字符串w :(1) 在w上运行M1。(2) 若M1接受则拒绝，若M1拒绝则接受。”时间复杂度为：O(na)。所以1L属于P类，即 P在补的运算下封闭 。7.7 证明NP在并和连接运算下封闭。(1) 并：对任意 L1, L2∈NP，设分别有na时间非确定图灵机M1和nb时间非确定图灵机M2 判定它们，且c=max{a,b}。构造判定L1∪L2的非确定图灵机M:M=“对于输入字符串w :1) 在w上运行M1，在w上运行M2。2) 若有一个接受则接受，否则拒绝。”对于每一个非确定计算分支，第一步用时为O(na)+O(nb)，因此总时间为O(na+nb)=O(nc)。 所以L1∪L2∈NP，即 NP在并的运算下封闭。(2) 连接：对任意 L1, L2∈NP，设分别有na时间非确定图灵机M1和nb时间非确定图灵机M2 判定它们，且c=max{a,b}。构造判定L1L2的非确定图灵机M:M=“对于输入字符串w :1) 非确定地将分成两段x,y，使得w=xy。2) 在x上运行M1，在y上运行M2。3) 若都接受则接受，否则拒绝。”对于每一个非确定计算分支，第一步用时O(n),第二步用时为O(na)+O(nb)，因此总时间为O(na+ nb)=O(nc)。 所以L1L2∈NP，即NP在连接运算下封闭。专题——图灵机可判定性问题判定以下问题是否可判定：声明：思路——想证明B问题不可解， 从一个不可解问题A入手（如停机问题） 创建B的一个实例，从中推出如果能解决B，A也就可以解决了 所以B是不可解的 一个图灵机有至少481个状态。我们可以给出这样一个TM N进行enc（M），a) 数M中状态数，直到481.b) 如果达到了481，N就接受，否则拒绝。 给定图灵机在空串上走了481步还没停机。构造2带图灵机N，a) 2nd 带: 写481个 0b) 1st 带在空串上模拟M，每走一步，第2带就删掉一个0c) 如果M在所有0都删掉之后停机，则N接受，否则不接受 给定图灵机，判定它是否在一些输入上经过481步还没停机？a) 按字典序找出所有length&lt;=481的串xb) 在每个x上面run M，看是否在481步以内停机c) 是则接受，否则reject 给定图灵机，判定在所有输入上是否经过481步还没停机？a) 原因同(3)类似 给定图灵机是否接受空串？设两个语言：L1 = {M|M(e)停机}；H = {&lt;M,w&gt;|M(w)停机}已知H不可判定，只需要找到H-&gt;L1的归约即可。令f(“M”,“w”) =M’(y) = “M(w)”, M’ 输入任何y的输出都是M在w上的模拟结果（获得的具体做法是删除任何输入，写入w，再在w上模拟M）。则{“M”,”w“}∈H，iff M’ 在任何串上停机，iff M’在空串停机 M‘∈L1。 ①给定TM M，是否存在在M上停机的串？②给定TM M， M是否在所有上停机的串？设L = {M|M(a) where a∈Σ} ，H = {&lt;M,w&gt;|M(w)停机}。寻找H到L的归约。令f(“M”,“w”) =M’(y) = “M(w)”, M’ 输入任何y输出都是M在w上的模拟结果（获得的具体做法是删除任何输入，写入w，再在w上模拟M）。{“M”,”w“}∈H，iff M’ 在任何串上停机，iff M’在任何串上停机，iff M’在所有a上停机(a∈Σ), i.e. M’∈L。 给定TM M，is L(M) finite? 设Finite = {L(M) where L(M) is finite}; AH = {&lt;M,w&gt;|M accept w}存在从AH（非递归）到﹁Finite的递归函数f，f(“M”,“w”) =M’(y) = “M(w)”, 显然f可计算。则{M,w}∈AH ⇔ M halts on w ⇔ M’ accept any y∈Σ* ⇔f(M,w) is infinite, i.e. M’∈ ﹁Finite。由于AH归约到﹁Finite，所以﹁Finite非确定，又∵确定性在补下封闭，所以Finite也是非确定的。 给定TM M, 带上是否出现过a（a∈Σ）？设Write_a = {&lt;M,w&gt;|M有一条在带上写a的规则}；AH = {&lt;M,w&gt;|M accept w}存在从AH（非递归）到﹁Finite的递归函数f，f(“M”,“w”) =M’(“T”,”a”) = Simulate M(w).若M接受w，在带上写a；否则什么也不写。则{M,w}∈AH ⇔ M halts on w ⇔M’在带上写了一个a⇔ f(“M”,“w”)∈Write_a. 所以Write_a非确定。 给定M1，M2，它们是否在一个相同串上停机？设2Halts = {&lt;M1,M2&gt;|存在令他们都停机的串w}；H = {&lt;M,w&gt;|M(w)停机}构造新机器M’，在M’带上写w，模拟M1若停机则清空带，写w，再模拟M2，若M2在w上也停机，则M’停机。则有M’停机⇔&lt;M1,M2&gt;∈2Halt ⇔&lt;M1,w&gt;∈H且&lt;M2,w&gt;∈H。 给定M，只要M接受w，M就接受wR 设S = {M| M accepts wR whenever it accept w}; AH = {&lt;M,w&gt;|M accept w}递归函数f定义如下，f(M,w) = M’(y), 在M’上模拟M(w).当M接受w时，create M’ 只接受串1111；当M拒绝w时，create M’只接受串01。则&lt;M,w&gt;∈AH ⇔ M接受w ⇔ M’只接受1111 ⇔ M’∈S，类似的&lt;M,w&gt;∉AH⇔M’接受01不接受10⇔M’∉S判定语言Recursive/Recursive Enumerable / Not R.e. L1 = {M| there exists an input on which M halts in less than || steps} R.Test on all w less than |M| L2 = {M| |L(M)|&lt;4} Not R.e.a) Reduction from H , 说明是R.e.或非R.e.b) &lt;M,x&gt;∈非H，当且仅当M’属于L2 L3 = {M| |L(M)|&gt;2} R.e. not R]]></content>
      <tags>
        <tag>计算理论</tag>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《区块链+赋能数字经济》读书笔记]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%B5%8B%E8%83%BD%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%2F</url>
    <content type="text"><![CDATA[这几天看了颜阳老师写的一本书《区块链+赋能数字经济》，感悟挺多，所以又来写日报了。这本书首先介绍了区块链的前世今生，然后笼统的介绍了区块链技术架构和发展趋势，之后介绍了数字经济与区块链的联系，同时也介绍了区块链相关的法律法规进展情况，还介绍了区块链的一些应用场景，之后介绍了区块链和大数据还有物联网怎样有机地结合，最后结合实际产业阐述区块链的应用案例。总的来说，这本书更适合业务人员看，里面几乎不涉及技术层面的知识，但是我认为要想研究一项技术首先要知道这个技术适合解决什么问题，如何解决和技术本身的特性，所以这本书对我的启发很大。但是从这本书中我发现了两处错误，第一处是fabric的共识，在2017年下半年fabric发布1.0.0版本中就已经摒弃PBFT共识机制了，此书写于2018年上半年，所以不应该写fabric共识机制是PBFT；第二处错误是错别字，可能在印刷前没有认真校对导致的。看完这本书我更加坚定了去研究一下IPFS，在我最近读的两本书中都提到了这个技术。读这本书我最大的感悟是作者逻辑清晰，文笔不错，但是书中的很多案例比如说区块链+保险，区块链+游戏，区块链+媒体等等等等，我从技术角度来看目前这些都存在一定的漏洞，缺乏可落地的条件。虽然这本书的受众更倾向于产品经理，但是我作为一个技术人员还是从中得到一些启发。 读书笔记共享经济本质是通过减少信息不对称，实现资源优化配置。这句话给我了启发，这不正好是区块链能做的事情嘛，所以我在思考区块链可以为共享经济做些什么！ 价值互联网书中提到了这个名词，我去Google了一下，得到如下的解释：区块链能实现了从信息互联网转变成价值互联网。价值互联网将来就是一个个覆盖面巨大的分布式账本：从金钱、股票到身份信息、音乐都可以储存其中，并能够完成点对点交易。交易者之间的信任不是由中介机构创造，而是由加密技术本身来创造，由协作的功能、完整的代码完成，这就是区块链技术和思想。也许将来我们不再需要强大的中介机构，而是通过原始的价值就能完成交易。价值互联网的两大技术基础：移动互联网、数字货币。我看知乎一个回答的挺透彻，真正促进价值互联网的不是区块链技术，而是移动互联网技术，在网络发展初期人们把互联网称为移动互联网，其实也可以称为价值互联网，毕竟网络中产生的数据等是有价值的，但是那时候价值互联网这一词没有被人们广泛接受，其中重要的原因就是互联网并没有那么普及，直到移动互联网出现，互联网走进千家万户，这时候价值互联网一词才进入大众视野。所以从这一点来说价值互联网的普及并不是因为区块链技术。只能说区块链技术促进了价值互联网。区块链技术从一定程度上促进了信息的传播和价值的交换。 那些业务最适合用区块链作者指出多方参与，但由于缺乏公信机制，存在过程冗长信息不对称，易产生摩擦或纠纷的业务，以及要增强可信度控制的资本，资产相关的业务交易都适合用区块链技术。其实我反倒觉得并不是这样的，区块链技术还处于薄雾之中，很少有人能看清技术的本质，当然我也是一样，仅看透技术本质才能知道其最适合应用的场景。如果让我为这个问题给出一个答案，我会说具体问题具体分析。 架构的创新比新技术的发明更重要作者认为架构的创新比新技术的发明更重要，这一点我非常认同，毕竟区块链也仅是几项旧技术新架构的创新。 作者指出目前区块链技术存在的问题书中所述的问题是大家都共识的问题，这也给我后期的研究指明了方向。 区块链应用场景这一部分几乎占全书一半的篇幅，可能能给后人一些启发。但是每种应用案例没有给出具体的描述，仅从业务层面进行了分析，我发现每种案例深入研究都会存在不可行的地方，当然我相信随着技术的进步，都会落地。]]></content>
      <tags>
        <tag>日报</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《去中心化应用—区块链技术概述》读书笔记]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%AF%B9%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%96%B0%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[感觉这个博客主要功能是记录我学习路线，像在公司写日报一样不想写大论文，闲来没事就想去图书馆看看书，开拓自己的思路。今天看了一本书，美国Siraj Raval所著，书名是“去中心化应用—区块链技术概述”，是非常小也非常薄的一本书。这本书前半部分部分很容易理解，主要介绍了去中心化应用、数据、财富、身份标识、计算、宽带和去中心化资产的去中心化市场；书的后半部分更容易理解，说了几个典型的DAPP，包括IPFS、OpenBazaar、Lighthouse、La’Zooz。 以下是我整理的读书笔记和感悟：书中说区块链的创新之处就在于第一次无须使用中心服务器就能达成去中心化共识，其实传统的分布式共识算法或多或少都需要中心控制结点，比如说PBFT、raft、Paxos算法，反之区块链利用PoW、PoS、DPos算法可以实现无须中心服务器的共识，其实严格意义说只有DPoS也不算是，毕竟它需要预先指定记账结点的数量。盈利的DAPP有有如下四个特性：1）开源；2）内部货币；3）去中心化共识；4）没有中心失效结点；开源的DAPP更能获得用户的信任，开源让各位大佬们研究DAPP源码也是一种变相的宣传；内部货币主要是用于内部激励，帮助DAPP获得高的用户忠诚度，同时也实现DAPP可持续发展；去中心化共识这本身就是区块链技术具有的特点；没有中心失效结点这个也保证DAPP不会因为黑客攻击或者政府审查而崩溃。读这本书我产生一点疑问：开源DAPP除了利用内部货币或者从中抽成盈利，还有别的盈利手段吗？如果有小伙伴有自己的见解欢迎和我讨论！PoW设计思想是目前为止唯一能防范女巫攻击的系统。未来数据将变成价值的主要形态。作者狠狠的夸赞了一番IPFS，这也让我对IPFS产生了强烈的兴趣，有时间我会去研究一下。文中提出一个Zooko三角，说的是去中心化、安全和对人类有意义三者只能取其二，当然这个我是不赞同的，比特币就是一个很好的代表。但是作者其中一个想法我觉得不错：不用创造完全没有信任关系的系统，而是应该创建更加可信的系统。最后介绍一个文中提到的几个DAPP都是做什么的：1）IPFS：去中心化数据存储，解决数据存储问题，用DHT保存数据，基于内容寻址，所有数据都是公开的意味着上传的数据要自己提前加密；2）OpenBazaar：去中心化市场，没有人可以把这个市场关闭，可以实现真正意义上的自由买卖；3）Lighthouse：去中心化众筹，解决的是中间商赚差价的问题；4）La’Zooz：去中心化打车平台，类似于UBER，利用内部代币实现激励机制；以上这几个DAPP其实都处于发展的早期，至于未来能爆发多大的潜力我们拭目以待！]]></content>
      <tags>
        <tag>日报</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算，雾计算，边缘计算和区块链的关系]]></title>
    <url>%2F2018%2F11%2F15%2F%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%9B%BE%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%9C%B2%E8%AE%A1%E7%AE%97%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[最近在看云计算，雾计算、边缘计算和露计算，结合区块链产生了一些新的思考。毕竟年纪大了，有重要的东西就只能抓紧记下来，以免今晚睡一觉就什么也记不得了。以下有是我根据各大网站、论文、书籍整理的相关内容。（如若侵权，请邮件联系我！） 云计算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云计算是一种利用互联网实现随时随地、按需、便捷地使用共享计算设施、存储设备、应用程序等资源的计算模式。云计算系统由云平台、云存储、云终端、云安全四个基本部分组成。云平台从用户的角度可分为公有云、私有云、混合云等。通过从提供服务的层次可分为基础设施即服务（Iaas）、平台即服务（Paas）和软件即服务（Saas），目前还出现了区块链即服务（BaaS）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发者将应用部署到云端后，可以不必再关注那些令人头疼的硬件和软件问题，它们会由云服务提供商的专业团队去解决。使用的是共享的硬件，这意味着像使用一个工具一样去利用云服务。只需要按照你的需要来支付相应的费用，而关于软件的更新，资源的按需扩展都能自动完成。但是现阶段云计算存在计算延迟、拥塞、低可靠性、安全攻击等问题，为了应对这些问题，提出雾计算和露计算等概念。 雾计算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;雾计算旨在终端（个人电脑，手机等）和数据中心之间再加一个网络边缘层（例如再加一个带有存储器的小服务器或路由器），把一些不需要放到“云”上的数据在这一层直接处理和存储，以减少“云”的压力，提高了效率，也提升了传输速率，减低了时延。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;雾计算并非是些性能强大的服务器，而是由性能较弱、更为分散的各种功能计算机组成，雾计算是介于云计算和个人计算之间的，是半虚拟化的服务计算架构模型，强调数量，不管单个计算节点能力多么弱都要发挥作用。与云计算相比，雾计算所采用的架构更呈分布式，更接近网络边缘。雾计算将数据、数据处理和应用程序集中在网络边缘的设备中，而不像云计算那样将它们几乎全部保存在云中，数据的存储及处理更依赖本地设备，而非服务器。雾计算是新一代分布式计算，符合互联网的“去中心化”特征。自从思科提出了雾计算，已经有ARM、戴尔、英特尔、微软等几大科技公司以及普林斯顿大学加入了这个概念阵营，并成立了非盈利性组织开放雾联盟，旨在推广和加快开放雾计算的普及，促进物联网发展。雾计算是以个人云，私有云，企业云等小型云为主。从上面的描述中可以看出雾计算已经出现分布式的特点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云计算重点放在研究计算的方式，雾计算更强调计算的位置，它们在网络拓扑中的位置不同。雾计算介于云计算和个人计算之间的，是半虚拟化的服务计算架构模型。此外，雾计算实际上并没有强力的计算能力，雾计算是将物理上分散的计算机联合起来，形成较弱的计算能力，不过这样的计算能力对于中小型的数据中心，完全够用了，雾计算弥补云计算本地化计算问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多抽象的理论，到底雾计算有哪些应用呢？雾计算通常和物联网技术结合实现落地。物联网发展的最终结果就是将所有的电子设备，移动终端，家用电器等一切都互联起来，这些设备不仅数量巨大，而且分布广泛，只有雾计算才能满足，有了雾计算才使得很多业务可以部署。例如智能交通灯，针对移动性和位置信息的计算，计算量不大，但是对时延要求高，显然只有雾计算最适合。试想如果城市中的所有交通灯都需要有数据中心云计算来统一计算而指挥所有交通灯，这样不仅不及时也容易出错。智能交通灯本意是根据车流量来自动指挥车辆通行，那么实时计算非常重要，雾计算使得每个交通灯自己都有计算能力，从而自行完成智能指挥。 边缘计算（MEC）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前还处于概念阶段，乍一看雾计算和边缘计算好像是一个东西，翻阅很多资料我发现，边缘计算概念出现时间上早于雾计算，处理能力更靠近数据源。雾计算可以进行边缘计算，但除了边缘网络，雾计算也可以拓展到核心网络，也就是边缘和核心网络的组件都可以作为雾计算的基础设施，而边缘计算更多地专注于终端设备端；雾计算在节点之间具有广泛的对等互连能力，边缘计算在孤岛中运行其节点，需要通过云实现对等流量传输。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以吸尘器为例说明，集中化的雾节点(或者IoT网关)继续从家中的传感器收集信息，检测到垃圾的话就启动吸尘器；边缘计算的解决方案里传感器各自判断有没有垃圾，来发送启动吸尘器的信号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;雾计算与边缘计算都是将智能和计算能力推向靠近数据来源的位置，因此他们常常被混用。他们的区别也正是计算能力所处的位置：1）雾计算将计算能力推向局域网，在雾节点或物联网的网关处完成数据处理；2）边缘计算将边缘网关的智能，处理能力和通信能力直接推送到诸如可编程自动化控制器的设备；下图可以看出两者区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是从网络上copy的边缘计算优缺点：优点1）接近实时的数据处理：因为数据是在边缘结点进行分析，降低了延迟，提升应用的响应速度；2）减少数据传输：数据不需要推送到遥远的云端，减少智能设备和数据中心传输的数据量，节省带宽成本，同时还能减小核心网络的拥堵。比如facebook等社交软件的用户上传的照片在边缘调整到合适的分辨率再上传到云端；3）数据安全：一些比较敏感的数据直接在边缘进行分析，不用当心数据泄漏；4）提高可用性：分担（offload）了中心服务器的计算任务，一定程度上消除了主要的瓶颈，并且降低了出现单点故障的可能；缺点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何东西都是有缺点的，如果只看到优点说明理解的不够深入。边缘计算还处于概念阶段，同样存在很多问题，比如：1）使边缘设备具有处理能力意味着更高的成本和更容易被入侵的危险；2）在大量的边缘设备上进行应用部署和服务监控会成为一个棘手的问题；3）在边缘进行分布式计算并与云端协调任务会让应用编程变得更加复杂； 和区块链的一些思考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区块链作为一种分布式计算范式，发展的历程也是经受很多坎坷。想象一下假如可以利用区块链技术帮助云计算、雾计算和边缘计算获得更高的性能是不是很棒呢！在IOT中所有的设备都可以无人工干预的情况下连接到区块链中，这些设备成为区块链中的结点，其中产生的数据直接传到区块链网络中，这样每个IOT设备都可以扩展自己本身的能力，例如加入数据分析能力，利用其余设备传上链的数据直接在终端中进行数据分析从而做出更好的决策。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以智能交通等为例，假如所有交通灯都可以看作一个IOT设备，同时也可以看作一个区块链结点，一个城市所有的交通灯构成区块链系统的结点，每个结点之间贡献数据，同时这个网络有一定的数据分析能力。当A道路拥挤时，与之相连的B和C道路可以获得从A交通灯收集的数据快速分析后可以实时调整B和C交通灯的时长，从而自动缓解交通压力。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，目前这仅仅是想法，但是我相信随着IOT和区块链技术的发展，此想法终究会实现。拭目以待！]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>cloud computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ubuntu18.04的fabric1.2.0网络中手动部署chaincode（完全跑通版）]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%9C%A8ubuntu18-04%E7%9A%84fabric1-2-0%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2chaincode%EF%BC%88%E5%AE%8C%E5%85%A8%E8%B7%91%E9%80%9A%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先根据官方网站给出的步骤部署好fabric网络官方网站地址：https://hyperledger-fabric.readthedocs.io/en/release-1.2/getting_started.html 在fabric/scripts/fabric-samples/first-network目录下执行如下操作：//修改docker-compose-cli.yaml中的CORE_LOGGING_LEVEL = DEBUGCORE_LOGGING_LEVEL = DEBUG //用cryptogen工具产生证书cryptogen generate //用configtxgen创建创世快，channel和peercryptogen generate –config=./crypto-config.yamlexport FABRIC_CFG_PATH=$PWDconfigtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block //常见通道配置事务export CHANNEL_NAME=testchannel &amp;&amp; configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME //为org1和org2锚定peerconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx-channelID $CHANNEL_NAME -asOrg Org1MSP configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx-channelID $CHANNEL_NAME -asOrg Org2MSP //打开网络docker-compose -f docker-compose-cli.yaml up -d //配置环境变量for PEER0export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=”Org1MSP”exportCORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt //在网络中加入其它的通道docker exec -it cli bash //进入cli容器（这是进入默认的org1.peer0的） 可以通过下面的修改默认的Environment variables for PEER0export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=”Org1MSP”exportCORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt //配置环境变量export CHANNEL_NAME=testchannel //创建通道peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx–tls –cafile peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx –tls –cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem //把peer加入channel（此时是peer0.org1.example.com）peer channel join -b mychannel.block 修改环境变量把其他的peer加入channelEnvironment variables for PEER0CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer0.org1.example.com:7051CORE_PEER_LOCALMSPID=”Org1MSP”CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt Environment variables for PEER1CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051CORE_PEER_LOCALMSPID=”Org2MSP” CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block //执行更新锚节点配置命令peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx–tls –cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 如果需要加入其它组织，变更脚本变量后执行更新锚节点操作即可，至此，手动配置网络完成, 可以编写并测试链码。 //切换至：pee0.org1.example.comCORE_PEER_LOCALMSPID=”Org1MSP”CORE_PEER_ADDRESS=peer1.org1.example.com:7051CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabri c/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fa bric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.exa mple.com/tls/ca.crt //查看环境变量echo $CORE_PEER_LOCALMSPID #确认当前指定的orgecho $CORE_PEER_ADDRESS #确认当前指定的peerexport CHANNEL_NAME=mychannel #设置通道名称 //把本地写好的链码复制到docker cli容器中docker cp 本地路径 容器长ID:容器路径 //安装链码peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/store/ //实例化链码peer chaincode instantiate -o orderer.example.com:7050 \–tls –cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \-C $CHANNEL_NAME \-n mycc -v 1.0 \-c ‘{“Args”:[“str”,”helloworld”]}’ \-P “OR(‘Org1MSP.peer’,’Org2MSP.peer’)” //测试链码get操作peer chaincode query -C $CHANNEL_NAME -n mycc -c ‘{“Args”:[“get”,”str”]}’ //测试链码set操作peer chaincode invoke -o orderer.example.com:7050 \–tls –cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \-C $CHANNEL_NAME -n mycc \-c ‘{“Args”:[“set”,”str”,”hi zhaoyao”]}’ 部署过程中遇到的错误及改正措施：创建channel时出错，Orderer log如下 解决办法：清空所有docker容器，清空所有的环境从新开始部署。 遇到什么问题可以给我留言，或者发邮件给我，我会及时给大家回复~]]></content>
  </entry>
  <entry>
    <title><![CDATA[谈谈我与区块链的两三件事]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%B0%88%E8%B0%88%E6%88%91%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[我与区块链的缘分，从2016年开始。2016年底实验室开组会，听到导师随口提了一句区块链，自此区块链这个词伴随我走过了两年多的时间。最开始了解到的还是比特币，当时一个比特币只有几千块钱，想想如果那时候有远见哪怕买上一个，现在我也是穷学生中的“富翁”了吧。慢慢地，区块链渐渐从比特币中脱离出来，成为独当一面受追捧的新技术，假如区块链有灵魂，现在是不是能开心的飞起来呢。以太坊作为我的启蒙老师，让我在理论与实践的结合中快速成长。熟悉了区块链的基本思想，参与过几个公有链和联盟链的项目，期间最大的感受还是泡沫多于实用。近期忙于论文，有段时间没有接触区块链这个词了，感觉自己对他又陌生了一些，也能让我以旁观者的角度再审视一下区块链技术到底是什么。对于学经济管理的人主要研究区块链的经济学模型，货币体制，激励制度；学法律的人多在研究区块链背后涉及的法律法规和监管问题；学计算机的人更多是研究提高性能的加密算法、共识算法、状态通道等。作为一名工科生，自然是往技术层面去看。今天看到多牛资本董事长蒋海炳老师说的一句话，深受启发：信念坚定的人才适合做CEO。自诩我并不是一个信念坚定的人，我对区块链的认知像一条波浪线，当然这条线总体的趋势是上升的。有时觉得区块链真是个好技术可以解决这么多问题；有时觉得区块链是骗钱的没有实际作用。当然这是指以前对区块链理解不深刻的时候。现在我认为区块链会在各类基础设施都完善的基础上爆发巨大的力量。我这两年的研究主要想把区块链和服务计算结合起来做一些事情。你可能要问我什么是服务计算。我认为服务计算是一种分布式计算模式，随着各类基础设施的完善和网络应用的发展，现代企业存在因特网环境下企业交互、异构系统的集成和互操作、业务发生变化快速相应的能力等要求，使得企业内部或者各个企业之间的不同商业应用系统能实现快捷、灵活和无缝集成和相互协作。服务计算也分为很多研究方向，比如说SOA、网格计算/效用计算、业务流程管理等，其中Web服务作为SOA主要的实现方式也是研究的一个分支，我主要是研究服务计算中SOA分支下的Web服务组合问题。后期结合区块链技术研究怎么改进SOA的架构。把服务计算和区块链结合起来，用区块链技术消除服务计算中第三方角色，降低成本，提高效率。区块链作为一种思想同时也是一个技术，循环迭代，思想指导技术的发展；技术的发展又促进思想的进步，相辅相成。作为技术，需要实际应用于具体场景；作为思想需要指导技术的道路。我认为区块链最大的价值是量化那些很难被量化的权益或虚拟物品，如信用、名声等可以被资产化的数字形式媒介。我博士期间想继续深入研究区块链和服务计算的结合并且思考怎样把区块链和物联网结合起来，针对物联网特有的环境，研究区块链适合的共识算法和加密算法！想实现之前写的专利——先从智能酒店做起。博士期间还想解决最后一公里信任问题，目前用手机号注册账号可能会存在信息泄露的风险，直接关系到用户的隐私，怎样利用区块链技术减少电信诈骗是另一个研究方向。总结了一下硕士期间的成果和博士期间将要干的事情，希望所有人都能坚持自己的信念，并梦想成真。Take your passion and make it come true.]]></content>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到我的blockchain小天地，请原谅我起了一个这么俗的名字！]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
